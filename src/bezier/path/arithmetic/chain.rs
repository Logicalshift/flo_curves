use super::add::*;
use super::sub::*;
use super::chain_add::*;
use super::intersect::*;
use super::super::path::*;
use super::super::super::super::geo::*;

///
/// Description of an arithmetic operation to perform on a bezier path
///
/// A series of `PathCombine` operations can be used to describe how to build up a path by adding and
/// subtracting solid components.
///
#[derive(Clone, Debug)]
pub enum PathCombine<P: BezierPath>
where
    P::Point : Coordinate+Coordinate2D,
{
    /// Sets the result to a particular path
    Path(Vec<P>),

    /// Sets the result to a path with its interior points removed.
    ///
    /// Everything within the outermost boundary of the path will be removed: the path will be left with no
    /// 'holes' in it. This is useful for cleaning up things like paths generated by brush strokes that may
    /// self-overlap. See also `path_remove_overlapped_points()` for a way to clean up paths where every edge 
    /// is intended to be an exterior edge.
    ///
    /// This can be considered to be a slightly stricter version of the non-zero winding rule: the intention is
    /// that `PathCombine::Subtract` is used to cut holes in an existing path with this used to clean up input
    /// paths that might be self-overlapping.
    RemoveInteriorPoints(Vec<P>),

    /// Adds a series of paths
    Add(Vec<PathCombine<P>>),

    /// Subtracts a series of paths (from the first path)
    Subtract(Vec<PathCombine<P>>),

    /// Intersects a series a paths (with the first path)
    Intersect(Vec<PathCombine<P>>)
}

///
/// Performs a series of path combining operations to generate an output path
///
pub fn path_combine<P: BezierPathFactory>(operation: PathCombine<P>, accuracy: f64) -> Vec<P>
where
    P::Point: Coordinate+Coordinate2D,
{
    // TODO: it's probably possible to combine add, subtract and intersect into a single ray-casting operation using a similar technique to how path_add_chain works

    match operation {
        PathCombine::Path(result)               => result,
        PathCombine::RemoveInteriorPoints(path) => path_remove_interior_points(&path, accuracy),
        PathCombine::Add(paths)                 => path_add_chain(&paths.into_iter().map(|path| path_combine(path, accuracy)).collect(), accuracy),

        PathCombine::Subtract(paths)            => {
            let mut path_iter   = paths.into_iter();
            let result          = path_iter.next().unwrap_or_else(|| PathCombine::Path(vec![]));
            let mut result      = path_combine(result, accuracy);

            for to_subtract in path_iter {
                let to_subtract = path_combine(to_subtract, accuracy);
                result          = path_sub(&result, &to_subtract, accuracy);
            }

            result
        }

        PathCombine::Intersect(paths)            => {
            let mut path_iter       = paths.into_iter();
            let result              = path_iter.next().unwrap_or_else(|| PathCombine::Path(vec![]));
            let mut result          = path_combine(result, accuracy);

            for to_intersect in path_iter {
                let to_intersect    = path_combine(to_intersect, accuracy);
                result              = path_intersect(&result, &to_intersect, accuracy);
            }

            result
        }
    }
}
