use crate::bezier::vectorize::*;

use smallvec::*;

use std::ops::{Range};

///
/// Provides an implementation of `SampledContour` derived from a ray-casting function that
/// provides the intercepts along any y position
///
pub struct RayCastContour<TFn>
where
    TFn: Fn(f64) -> SmallVec<[Range<f64>; 4]>
{
    /// Function that maps a y position to the intercepts on the x axis
    intercept_fn: TFn,

    /// Size of the contour to return from this function
    size: ContourSize,

    /// Scale factor used to convert y positions into positions to pass to the intercept function
    scale_factor: f64,
}

impl<TFn> RayCastContour<TFn>
where
    TFn: Fn(f64) -> SmallVec<[Range<f64>; 4]>,
{
    ///
    /// Creates a new ray-cast contour
    ///
    /// The `intercept_fn` defines where the edges of the contour are by finding the ranges that are inside the contour at a 
    /// given y position. The size indicates the range of x and y positions that can be generated by the contour.
    ///
    /// The function must return the intercepts in ascending x order.
    ///
    #[inline]
    pub fn new(intercept_fn: TFn, size: ContourSize) -> Self {
        RayCastContour { 
            intercept_fn:   intercept_fn, 
            size:           size, 
            scale_factor:   1.0
        }
    }

    ///
    /// Sets the scale factor for the contour
    ///
    #[inline]
    pub fn with_scale(self, scale_factor: f64) -> Self {
        RayCastContour {
            intercept_fn:   self.intercept_fn,
            size:           self.size,
            scale_factor:   scale_factor
        }
    }
}

impl<TFn> Clone for RayCastContour<TFn>
where
    TFn: Clone + Fn(f64) -> SmallVec<[Range<f64>; 4]>,
{
    #[inline]
    fn clone(&self) -> Self {
        RayCastContour {
            intercept_fn:   self.intercept_fn.clone(),
            size:           self.size,
            scale_factor:   self.scale_factor,
        }
    }
}

impl<'a, TFn> SampledContour for &'a RayCastContour<TFn>
where
    TFn: Fn(f64) -> SmallVec<[Range<f64>; 4]>,
{
    /// Iterator that visits all of the cells in this contour
    type EdgeCellIterator = InterceptScanEdgeIterator<&'a RayCastContour<TFn>>;

    ///
    /// The size of this contour
    ///
    #[inline]
    fn contour_size(self) -> ContourSize { 
        self.size
    }

    ///
    /// Returns true if the specified point is inside the contour, or false if it's outside
    ///
    /// A y-value of 0 is considered to be the 'top' of the bitmap
    ///
    fn point_is_inside(self, pos: ContourPosition) -> bool {
        // Convert the y position to a coordinate
        let x       = pos.x() as f64;
        let y       = pos.y() as f64;
        let y       = y * self.scale_factor;
        let width   = self.size.width() as f64;

        // Everything outside of the x-range is not inside in the contour
        if x >= width {
            return false;
        }

        for intercept in (self.intercept_fn)(y) {
            if intercept.start <= x && intercept.end > x {
                return true;
            }

            if intercept.start > x {
                // Can give up early because the intercept function is assumed to return the intercepts in order
                return false;
            }
        }

        false
    }

    ///
    /// Returns an iterator that visits all of the cells that are on an edge (has at least one set and one unset bit in the ContourCell)
    /// starting from the top-left corner of the contour
    ///
    /// The position returned here is the position of the bottom-right corner of the cell containing the edge.
    ///
    #[inline]
    fn edge_cell_iterator(self) -> Self::EdgeCellIterator {
        InterceptScanEdgeIterator::new(self)
    }

    ///
    /// Given a y coordinate returns ranges indicating the filled pixels on that line
    ///
    /// The ranges must be provided in ascending order, and must also not overlap.
    ///
    fn intercepts_on_line(self, y: usize) -> SmallVec<[Range<usize>; 4]> {
        const EPSILON: f64 = 0.000000001;

        // Convert the y position to a coordinate
        let y       = y as f64;
        let y       = y * self.scale_factor;
        let width   = self.size.width() as f64;

        // Find the intercepts on this line
        let intercepts = (self.intercept_fn)(y);

        // Process them to create the final result: remove intercepts outside of the width of the cell, clip the remaining intercepts, round to usizes and then remove any 0-width intercepts
        intercepts.into_iter()
            .filter(|intercept| intercept.end >= 0.0 && intercept.start < width)
            .map(|intercept| {
                let start   = if intercept.start < 0.0 { 0.0 } else { intercept.start };
                let end     = if intercept.end >= width { width } else { intercept.end };
                start..end
            })
            .map(|intercept| {
                let min_x_ceil  = intercept.start.ceil();
                let max_x_floor = (intercept.end + 1.0).floor();

                // If the intercept is very close to the edge of the cell then assume a floating point rounding error
                let min_x_ceil = if min_x_ceil - intercept.start > (1.0 - EPSILON) {
                    // Could be rounding error :-/
                    min_x_ceil - 1.0
                } else {
                    min_x_ceil
                };

                let max_x_floor = if max_x_floor - intercept.end > (1.0 - EPSILON) {
                    // Another possible rounding error
                    max_x_floor - 1.0
                } else if max_x_floor - intercept.end < EPSILON {
                    // Final rounding error
                    max_x_floor + 1.0
                } else {
                    max_x_floor
                };

                let min_x = min_x_ceil as usize;
                let max_x = max_x_floor as usize;

                min_x..max_x
            })
            .filter(|intercept| intercept.start < intercept.end)
            .collect()
    }
}

/// Ray cast contour with a dynamic intercept function
pub type DynRayCastContour = RayCastContour<Box<dyn Fn(f64) -> SmallVec<[Range<f64>; 4]>>>;
